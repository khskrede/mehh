\section{Future work}

\subsection{Getting programs into Haskell-Python from GHC}

This project focused mainly on this task, which was thought to be simple.
However, due to a combination of reasons, this turned out not to be the case.
Mainly, inexperience; with Haskell, the GHC API, and functional languages in 
general. However, a lot of experience was gained during this project, and
future development will benefit from this.

The work involved in this will be revisiting the different possibilities to
achieve our goal. These options are:

\begin{itemize}
\item Write an external-core parser directly in RPython, using files generated by GHC.
\item Include development of extcore as a part of the project. This most likely a bad
idea, as this seems to be no easier than the alternatives.
\item Use the GHC API to generate JSCore, this is also nontrivial.
\item Create functionality to be linked into the GHC executable, in order to generate the
representation of JSCore. Also nontrivial.
\item Simply use the version of GHC matching the version of extcore. This will not be
a good idea for further development of the project, but may be a simple solution to get
a prototype working quickly.
\item Implement a Haskell pipeline in RPython, including parsing, typechecking and desugaring.
This will be a very large task.
\end{itemize}

\subsection{Rewrite the deserializer to proper RPython}

The deserializer is currently not written in proper RPython. 
Converting the code to RPython will alow it to be compiled to a JIT interpreter by
the RPython toolchain. This should not be a very big task, but it requires understanding
of the RPython coding style. There are also restrictions on how one may use the pypy parser
tools.

\subsection{Implement base Haskell libraries}

Implementing Haskell libraries is necessary to run any Haskell program passed 
through GHC. One option may be to implement (or automatically generate from GHC code) Haskell
primitive types, and to convert the Haskell base libraries to JSCore.

\begin{comment}
\subsection{Map GHC encoded Types to Haskell-Python}

Figure out how to create encoded types for Haskell-Python. It may be possible to
autogenerate these from GHC files.

"2.) understanding how GHC encodes types. The Core Haskell of the previous steps encodes the types of all functions in slightly low-level
ways. This needs to be understood and a mapping of these types to what
the Python Haskell interpreter provides needs to be written." 

\subsection{Set up GHC test environment for Haskell-Python}

Setting up the GHC test enviromnent for Haskell-Python would be very valuable
for development and bug fixing.

"3.) the actual interpretation of the Core language is mostly
implemented. There are probably some things missing, which will be
discovered by running some Haskell programs. For that end, it would be
good to find out whether there is a Haskell implementation test suite
and get it to run."

\subsection{Add built in Haskell types to run some Haskell benchmarks}

"4.) what is missing to run more non-pure Haskell programs are all the
built-in functions (e.g. those that perform arithmetic, I/O, call C
functions, etc) and built-in types (e.g. integers, floats, C-level types
like arrays and structs). These should be added step by step. This is an
essentially open-ended task. It would be good to add as many built-ins
so that some of the Haskell benchmarks can run."

\subsection{Optimize PyPy JIT for Haskell-Python}

"5.) JIT work: While the JIT of PyPy can mostly be automatically applied,
in practice a lot of careful work is needed to make sure that the
generated code is optimal (or at least good). To do that, a test suite
of Haskell snippets that explicitly compares the generated machine code
with what it should look like is needed, and then the careful adding of
some tests to this suite, together with the better placement of JIT
hints. This is both the hardest step, as well as the most exciting one."
\end{comment}
