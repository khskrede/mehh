
\section{External-core}

% New

The Core language is an intermediate language used by GHC. It is the internal
program representation in the compilers simplification phase. It appears to be a
subset of Haskell, but with explicit type annotations in the style of the polymorphic
lambda calculus ($F_w$). External-core
is an external representation of Core generated from Haskell, by using GHC with a compiler 
flag (\emph{-fext-core}). By using External-core, one
may implement just parts of a Haskell compiler, using the remaining parts from
GHC. For this project, GHC is used to generate External-core. This way, desugaring,
type checking, pattern matching and overloading is performed. The remaining task
is then to interpret the External-core representation. \cite{tolmach2010ghc}

The GHC-generated External-core uses z-encoding for special characters in names 
(variables, constructors, ...), for
a definition of the z-encoding, see appendix \ref{zencoding}. This is a good thing, as much
of the functionality represented by these names has to be implemented in RPython,
and special characters (like \#{}, or +) is not allowed in Python names (function
identifiers, class identifiers, ...).

Without using GHC to produce External-core, linking code into GHC would be an 
optional way of achieving this, which would be a difficult and large task.
Or, the GHC API could be used to do the same task more cleanly. \cite{tolmach2010ghc}

The initial starting point of this project was to use the GHC API, the reasoning
was that External-core is not fully parenthesized and more tricky to parse. Thus,
generating a fully parenthesized and more machine-readable format would make sense.
However, it turned out that this too was a complicated task. As the internal
datatypes of GHC representing Core does not match the description of External-core. 
The choice was
then made to use GHC-generated External-core as the base for creating a new intermediate
format that could be easily generated using available packages for manipulating
External-core (\emph{extcore} is used for this).

For a formal definition of External-core, see appendix \ref{coregrammar}.

\subsection{Evaluation of a program}

A program is evaluated by reducing the expression "main:ZCMain.main" to 
\emph{weak-head-normal-form} (WHNF), i.e. a primitive value, lambda abstraction, or 
fully applied data constructor. A heap is used to make
sure evaluation is shared. The heap contains two types; a \emph{thunk}, 
or a \emph{WHNF}. A thunk is an unevaluated
expression, also called a \emph{suspension}. A \emph{WHNF} is an evaluated expression, 
the result of evaluating a \emph{thunk} is a \emph{WHNF}. \cite{tolmach2010ghc}

\begin{comment}
\subsection{Informal semantics of Core}

Core resembles a explicitly-typed polymorphic lambda-calculus ($F_{w}$), with some additions,
local let bindings, algebraic type definitions, constructors, case-expressions, primitive types,
literals and operators.\cite{tolmach2010ghc}

\subsubsection{Program organization and modules}

Programs represented in Core are organized into modules corresponding directly to source-level
Haskell modules. A module identifier (\emph{mident}) consists of a \emph{package name} followed
by a module name. 

Each module may contain each of the following top-level declarations:
\begin{itemize}
\item{Algebraic datatype declarations:} each defining a type constructor and one or more data
constructors.
\item{Newtype declarations:} corresponding to Haskell newtype declarations, each defining a 
type constructor and a coercion name.
\item{Value declarations:} defining the types and values of top-level variables.
\end{itemize}


\cite{tolmach2010ghc}


\subsubsection{Namespaces}

There are five distinct namespaces:
\begin{enumerate}

\item module identifiers (\emph{mident})
\item type constructors (\emph{tycon})
\item type variables (\emph{tyvar})
\item data constructors (\emph{dcon})
\item term variables (\emph{var})
\end{enumerate}

A variable (type or term) may have multiple definitions within a module. However, they
never shadow one another, the scope of the definition of a variable never contain a
redefinition of the same variable. Type variables may be "shadowed". Thus if a variable has
multiple definitions, they must be local (let-bound).\cite{tolmach2010ghc}

\subsubsection{Types and Kinds}

\paragraph{Types:}

Types are described by type expressions, there are built from named type constructors
and type variables using type application and universal quantification.

There are a few primitive type constructors, such as \emph{Intzh}, described in the 
module \emph{GHC.Prim}. \emph{\%data} and \emph{\%newtype} declarations introduce additional
type constructors. Type constructors are distinguished by name only.\cite{tolmach2010ghc}

\paragraph{Coercions:}

Types may also be built using one of the primitive coercion operators.\cite{tolmach2010ghc}

\paragraph{Kinds:}

It is necessary to distinguish well-formed type-expressions by classifying them into
different \emph{kinds}. Core explicitly records the kind of every bound type variable.
\cite{tolmach2010ghc}

\paragraph{Lifted and unlifted types:}

Semantically, a type is \emph{lifted} if and only if it has a bottom as an element. We
need to distinguish them because operationally, terms with lifted types may be represented
by closures; terms with unlifted types may not.\cite{tolmach2010ghc}

\paragraph{Type constructors; base kinds and higher kinds:}

Every type constructor has a kind, depending on its arity and whether or not its
arguments are lifted.

Term Variables can only be assigned types that have base kinds: the base kinds are *,\# and ?.
The three base kinds distinguish the liftedness of the types they classify: * represents
lifted types; \# represents unlifted types; and ? represents the "open" kind, a type that
may either be lifted or not.

Of these, only * may appear in Core type declarations generated from user code; the other
two are needed to describe certain types in primitive (or otherwise specifically generated) 
code (which, after optimization may appear anywhere).

Since Haskell allows abstracting over type constructors, type variables may have higher kinds,
however, much more commonly they have kind *, so that is the default if a type binder omits a
kind.\cite{tolmach2010ghc}


\paragraph{Type synonyms and type equivalence:}

\subsubsection{Algebraic data types}


\subsubsection{Newtypes}


\subsubsection{Expression forms}


\subsubsection{Expression evaluation}

Core is intended to be a call-by-need language, in which expressions are only evaluated
once.

Evaluating a Core expression means reducing it to \emph{weak-head normal form} (WHNF),
i.e. a primitive value, lambda abstraction, or fully applied data constructor. Evaluating
a program means evaluating the expression main:ZCMain.main.

To make sure that evaluation is shared, a heap is used. Heap entry can be:

\begin{itemize}
\item Thunk
\item WHNF
\end{itemize}

Heap pointers point to heap entries: at different times, the heap pointer can point
to either a think or a WHNF, because the run-time system overwrites thunks with WHNFs
as computation proceeds. 

The suspended computation that a thunk represents might represent an evaluating one of 
three different kinds of expression. The run-time system allocates a different kind of 
thunk depending on what kind of expression it is:

\begin{itemize}
\item Thunk for a value definition has a group of suspended defining expressions.
\item Thunk for a function application (where the function is user-defined) has a 
suspended actual argument expression, and a binding between the formal argument and 
a heap pointer to that suspension.
\item Thunk for a constructor application has a suspended actual argument expression;
the entire constructed value has a heap pointer to that suspension embedded in it.
\end{itemize}

As computation proceeds, copies of the heap pointer for a given thunk propagate through
the executing program. When another computation demands the result of that thunk, the
thunk is forced: the run-time system computes the thunk's result, yielding a WHNF, and
overwrites the 


\subsection{Primitive module}

\end{comment}
