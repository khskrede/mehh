
\documentclass{article}

\usepackage{verbatim}
\usepackage{cite}
\usepackage{parskip}


\begin{document}

\title{Title}
\author{Author}
\maketitle

\begin{abstract}
Abstract
\end{abstract}

\clearpage

\tableofcontents

\clearpage

\section{Introduction}

\subsection{Motivation}

The motiviation behind the project is to see if a \emph{strongly-typed} 
\emph{non-strict} \emph{purely-functional} programming language, haskell, 
can benefit from just-in-time (JIT) compilation.

\subsection{Project description}

The system will use the GHC haskell library to generate the haskell a 
representation of the Core language and a simple haskell program to 
serialize this representation into JSON. This entails using GHC for
parsing, typechecking, desugaring and simplification.

The resulting code will then be deserialized by the PyPy haskell interpreter 
and executed.

\section{Haskell}

As a part of this project, haskell had to be studied. This subsection provides a
short overview of the key aspects of haskell.

...

For a technical overview of the glasgow haskell compiler (ghc) \cite{ghc}.

\section{Core}

Core haskell is an intermediate language used by GHC (glasgow haskell compiler),
All syntactic sugar is removed, type checking is performed, pattern matching is
translated into case-expressions (each of witch performs only a single level of
matching) and overloading is resolved.\cite{jones1992implementing} Following
is a description of haskell as presented by \cite{tolmach2010ghc}

The external representation of Core can be seen in figure... However, this 
textual representation was never used directly as the GHC API contains datatypes 
representing the language.

\subsection{Core language definition}

Definition of Core grammar:

TODO: Write definition of Core



\begin{tabular}{ r c l }
$module$	& $ \rightarrow $ 	& \%module $mident$ $\{ tdefg ; \}$ $\{ vdefg ; \}$	\\
$tdefg$ 	& $ \rightarrow $	& \%data $qtycon$ $\{ tbind \}$  =  $ \{ [ cdef \{ ; cdef \} ] \} $ \\
		& $ | $			& \%newtype $qtycon$ $qtycon$ $\{ tbind \}$ = $ty$	\\
$pair$		& $ \rightarrow $	& $string$ : $value$ 		\\
$array$		& $ \rightarrow $	& [ ]				\\
		& $ | $			& [ $elements$ ]		\\
$elements$ 	& $ \rightarrow $	& $value$			\\
		& $ | $			& $value$ , $elements$		\\
$value$		& $ \rightarrow $	& $string$			\\
		& $ | $			& $number$			\\
		& $ | $			& $object$			\\
		& $ | $			& $array$			\\
		& $ | $			& true				\\
		& $ | $			& false				\\
		& $ | $			& null				\\
$string$	& $ \rightarrow $	& ""				\\
		& $ | $			& " $chars$ "			\\
$chars$		& $ \rightarrow $	& $char$			\\
		& $ | $			& $char$ $chars$		\\

$char$		& $ \rightarrow $	& any Unicode character except $"$ \\ 
		&			& or $\backslash$ or control characters: \\
		&			& $\backslash\backslash$	\\
		&			& $\backslash /$ 		\\
		&			& $\backslash b$ 		\\
		& 			& $\backslash f$ 		\\
		&			& $\backslash n$		\\
		& 			& $\backslash r$ 		\\
		& 			& $\backslash t$ 		\\
		& 			& $\backslash u$ four-hex digits\\
$number$	& $ \rightarrow $ 	& $int$ 			\\
		& $ | $			& $int$ $frac$			\\
		& $ | $			& $int$ $exp$			\\
		& $ | $			& $int$ $frac$ $exp$		\\
$int$		& $ \rightarrow$ 	& $digit$			\\
		& $ | $ 		& $digit1-9$ $digits$		\\
		& $ | $ 		& - $digit$			\\
		& $ | $ 		& - $digit1-9$ $digits$	\\
$frac$ 		& $ \rightarrow $ 	& . $digits$ 		\\
$exp$		& $ \rightarrow $ 	& $e$ $digits$ 			\\
$digits$	& $ \rightarrow $ 	& $digit$			\\
		& $ | $ 		& $digit$ $digits$		\\
$e$		& $ \rightarrow $ 	& e				\\
		& $ | $ 		& e+				\\
		& $ | $ 		& e- 				\\
		& $ | $ 		& E				\\
		& $ | $ 		& E+				\\
		& $ | $ 		& E-				\\
\end{tabular}









\subsection{Generating Core}

Core is easily generated using the GHC API.

\section{JSON representation of Core}

"JSON (JavaScript Object Notation) is a lightweight data interchange format."

Since libraries exist for haskell and python this makes it ideal for our use,
in adition, the haskell library contains a pretty printer that makes the resulting
representation of Core easier to inspect.

Since most programming languages has libraries for JSON serialization

The JSON format was used for serializing and deserializing Core from haskell to RPython.
Following is a description of this process


TODO: Write about z-encoding of Core.


\subsection{Definition of JSON}

Definition of JSON grammar:

\begin{tabular}{ r c l }
$object$	& $ \rightarrow $ 	& \{ \}				\\
 		& $ | $			& \{ $members$ \} 		\\
$members$ 	& $ \rightarrow $	& $pair$			\\
		& $ | $			& $pair$ , $members$ 		\\
$pair$		& $ \rightarrow $	& $string$ : $value$ 		\\
$array$		& $ \rightarrow $	& [ ]				\\
		& $ | $			& [ $elements$ ]		\\
$elements$ 	& $ \rightarrow $	& $value$			\\
		& $ | $			& $value$ , $elements$		\\
$value$		& $ \rightarrow $	& $string$			\\
		& $ | $			& $number$			\\
		& $ | $			& $object$			\\
		& $ | $			& $array$			\\
		& $ | $			& true				\\
		& $ | $			& false				\\
		& $ | $			& null				\\
$string$	& $ \rightarrow $	& ""				\\
		& $ | $			& " $chars$ "			\\
$chars$		& $ \rightarrow $	& $char$			\\
		& $ | $			& $char$ $chars$		\\

$char$		& $ \rightarrow $	& any Unicode character except $"$ \\ 
		&			& or $\backslash$ or control characters: \\
		&			& $\backslash\backslash$	\\
		&			& $\backslash /$ 		\\
		&			& $\backslash b$ 		\\
		& 			& $\backslash f$ 		\\
		&			& $\backslash n$		\\
		& 			& $\backslash r$ 		\\
		& 			& $\backslash t$ 		\\
		& 			& $\backslash u$ four-hex digits\\
$number$	& $ \rightarrow $ 	& $int$ 			\\
		& $ | $			& $int$ $frac$			\\
		& $ | $			& $int$ $exp$			\\
		& $ | $			& $int$ $frac$ $exp$		\\
$int$		& $ \rightarrow$ 	& $digit$			\\
		& $ | $ 		& $digit1-9$ $digits$		\\
		& $ | $ 		& - $digit$			\\
		& $ | $ 		& - $digit1-9$ $digits$	\\
$frac$ 		& $ \rightarrow $ 	& . $digits$ 		\\
$exp$		& $ \rightarrow $ 	& $e$ $digits$ 			\\
$digits$	& $ \rightarrow $ 	& $digit$			\\
		& $ | $ 		& $digit$ $digits$		\\
$e$		& $ \rightarrow $ 	& e				\\
		& $ | $ 		& e+				\\
		& $ | $ 		& e- 				\\
		& $ | $ 		& E				\\
		& $ | $ 		& E+				\\
		& $ | $ 		& E-				\\
\end{tabular}

\subsection{JSON representation of Core}

TODO: Write definition for Core JSON grammar.

\subsection{Correctness}

Show how a sample program is correctly translated here...

\section{PyPy}

\subsection{A quick overview}

The PyPy project is basically two things:

\begin{enumerate}

\item The RPython toolchain; a set of compiler tools for programs written in 
RPython.

\item An implementation of Python using these tools.

\end{enumerate}

In this paper PyPy refers to former.

The basic concept of PyPy is to use a high-level language to allow rapid for
development of interpreters for a variety of platforms. By implementing a compiler
for RPython, interpreters for other languages can be written in RPython and 
compiled to any platform supported by the PyPy toolchain.

\subsection{RPython}

RPython is a restricted proper subset of Python, this enables easy analyzis 
as well as efficient compilation.

\subsection{Translation toolchain}


\subsection{Just-in-time compilation}

The reason why PyPy is able to compete with other language implementations
on speed is it's tracing, or rather meta-tracing, JIT. The JIT is implemented
for RPython, but through a set of compiler hints, it is able to trace the 
execution of the application interpreted by the RPython program.

An introduction to virtual machine (VM) construction with python \cite{pypy}.


\subsection{Interpreting Core}

TODO: The haskell interpreter was allready written. Write about how it works.

\subsection{Python haskell libraries}

Describe implemented library functions. Most likely some small subset of the Base package.

\section{Testing}

TODO: Show tests???

\section{Benchmarks}

TODO: Show benchmarks???

\bibliographystyle{unsrt}

\bibliography{papers}

\begin{enumerate}
\item XXX
\end{enumerate}

\end{document}
