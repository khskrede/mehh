
\chapter{Core' interpreter}

% TODO: Fix this section.

Haskell-Python is an interpreter for a language similar to Core, we call it Core' here.
This interpreter is the base for our JIT compiler. In this chapter we explain the 
operational semantics of the Core' interpreter, so that we can later discuss the 
extensions that are necessary to make it a full Haskell interpreter.

% TODO: Are any extensions necessary.

\section{Launchbury semantics}

The \emph{Launchbury semantics} is an \emph{operational semantics} for \emph{lazy evaluation}, 
which our interpreter follows rather closely. This section
will be a brief introduction to the \emph{Launcbury semantics}, for a more complete introduction;
see \cite{launchbury1993natural}. 

\subsection{Normalising terms}

\normalfont\itshape 
x $\in$ Var 
\normalfont
\begin{grammar}
 <e $\in$ Exp> ::= $\lambda$ <x> . <e>
              \alt <e> <x>
              \alt <x>
              \alt let $x_1 = e_1, \; ... \; x_n = e_n$ in $e$
\end{grammar}


\subsection{Dynamic semantics}

The rewriting rules are presented below... The following naming conventions
are used:

\begin{grammar}
<$\Gamma$, $\Delta$, $\Theta$ $\in$ Heap> = <Var> $\mapsto$ <Exp>

<z $\in$ Val> ::= $\lambda$ <x> . <e>
\end{grammar}

\subsubsection{Lambda}

A lambda abstraction is simply a function definition and cannot be reduced.

\begin{equation}
\Gamma \; : \; \lambda x . e \; \Downarrow \; \Gamma \; : \; \lambda x . e
\end{equation}

\subsubsection{Application}


An application is the combination of reducing a named expression $e$ to a lambda abstraction
and applying a value to it.

\begin{equation}
\dfrac{\Gamma : e \Downarrow \Delta : \lambda y . e' \;\;\;\;\;\;\;\;\; \Delta : e' [x/y] \Downarrow \Theta : z }{ \Gamma : e \; x \Downarrow \Theta : z}
\end{equation}

\subsubsection{Variable}



\begin{equation}
\dfrac{\Gamma : e \Downarrow \Delta : z}{( \Gamma , x \mapsto e) : x \Downarrow (\Delta , x \mapsto z) : z' }
\end{equation}

\subsubsection{Let}

\begin{equation}
\dfrac{(\Gamma , x_1 \mapsto e_1 \; ... \; x_n \mapsto e_n) : e \Downarrow \Delta : z}{ \
\Gamma : let \; x_1 = e_1 \; ... \; x_n = e_n \; in \; e \Downarrow \Delta : z }
\end{equation}


\subsubsection{Constructors}

\begin{equation}
\Gamma : c \; x_1 \; ... \; x_n \Downarrow \Gamma c \; x_1 \; ... \; x_n
\end{equation}

\subsubsection{Case}

\begin{equation}
\dfrac{ \Gamma : e \Downarrow \Delta : c_k \; x_1 \; ... \; x_{m_k}  \;\;\;\;\;\;\;\;\; \Delta : e_k [x_i/y_i]^{m_k}_{i=1} \Downarrow \Theta : z }{ \Gamma : \; case \; e \; of \; \{c_i \; y_1 \; ... \; y_m \mapsto e_i\}^{n}_{i=1} \Downarrow \Theta : z }
\end{equation}

\subsubsection{Primitive}

\begin{equation}
\dfrac{\Gamma : e_1 \Downarrow \Delta : n_1  \;\;\;\;\;\;\;\;\; \Delta : e_2 \Downarrow \Theta : n_2 }{ \Gamma : e_1 \oplus e_2 \Downarrow \Theta : n_1 \oplus n_2 }
\end{equation}





\section{The interpreter}
















\section{Extensions}


\subsection{Currying and Partial function application}



The following extensions was made to the Core' interpreter to aid in the conversion from
Core to Core':

\begin{itemize}
\item Added a function $make\_partial\_app$ that takes a $PartialApp$ and a argument, and returns
a $PartialApp$ if the numbers of arguments collected does not match the number of arguments required,
otherwise, it returns an $Application$
\end{itemize}






\subsection{JSCore parser}

\subsection{GHC Haskell libraries}



\subsection{Primitives}


