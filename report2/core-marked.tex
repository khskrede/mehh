



\chapter{Core' interpreter}

Haskell-Python is an interpreter for a language similar to Core, we call it Core' here.
This interpreter is the base for our JIT compiler. In this chapter we explain the 
operational semantics of the Core' interpreter, so that we can later discuss the 
extensions that are necessary to make it a full Haskell interpreter.

\section*{Launchbury semantics}

The interpreter follows the Launchbury semantics for lazy evaluation rather closely.
The launchbury semantics is an operational semantics for lazy evaluation. This section
will be a brief introduction to the Launcbury semantics, for a more complete introduction;
see \cite{launchbury1993natural}. 

\section*{The interpreter}


\section*{System $F_w$}

For a class-diagram, see .....

\subsection*{Symbol}

A cached symbol that can be compared by identity (which is not true for strings).

\subsection*{HaskellObject}

Base class for objects that the interpreter handles.

\subsubsection*{Value}

\begin{itemize}
\item{$Constructor$} A constructor. This is an abstract base class, subclasses are 
generated in ConstructorN for various arguments.
\item{$AbstractFunction$} The $AbstractFunction$ is a base class for functions. The 
$Function$ and $PrimFunction$ classes inherits it. The $Function$ class describes
user-defined functions (i.e. written in haskell). The $PrimFunction$ class describes
primitive functions (i.e. a function not implemented in Core', but at the machine level)
\item{Other Values}
\end{itemize}

\subsubsection*{Substitution}

\subsubsection*{Var}

\subsubsection*{NumberedVar}

\subsubsection*{Application}

\subsubsection*{Thunk}

\subsection*{Rule}

One rule of a user-defined function.

\subsection*{StackElement}

\subsubsection*{CopyStackElement}

\subsubsection*{UpdateStackElement}



\section{Extensions}


\subsection{Currying and Partial function application}



The following extensions was made to the Core' interpreter to aid in the conversion from
Core to Core':

\begin{itemize}
\item Added a function $make\_partial\_app$ that takes a $PartialApp$ and a argument, and returns
a $PartialApp$ if the numbers of arguments collected does not match the number of arguments required,
otherwise, it returns an $Application$
\end{itemize}






\subsection{JSCore parser}

\subsection{GHC Haskell libraries}



\subsection{Primitives}


