
\chapter{Conclusion and Future Work}
\label{chap:conc}







\section{Primitives and Libraries}

\subsection{The initial plan}

GHC uses a module called GHC.Prim, located in the ghc-prim package. This
module is generated automatically from a file called "primops.txt.pp", this file
contains information about the machine representations of the various types, as
well as the operations that can be performed on them.

Initially, it was assumed that it would be trivial to translate the Haskell
libraries used by GHC into External-Core using GHC. This way, it would only 
be necessary to implement the primitive types and functions.

The External-Core functionality of GHC has bitrotted, and because of this, it can't be
used to create External-Core files for all the GHC libraries. This is a GHC bug. 
Although it produces correct
External-Core for some Haskell code, it does not for all. Since many crucial library files
can not be created External-Core for, we can not continue to use this approach.

\subsection{Our approach}

Currently, GHC is used to parse, typecheck, desugar and generate the 
External-Core representation of our program. By implementing the
primitive types and library functionality in Python, we are able to
get some simple programs running.


\subsection{Why it does not work}

% TODO: Libraries use Haskell code not supported by the External-Core libraries.

The initial reasoning for using External-Core was as follows;
it has a clearly defined syntax that is easy to work with, and it was 
assumed that it was decently supported. Unfortunately, there are bugs in
the parts of GHC responsible for generating External-Core, this in turn
results in the fact that we are unable to create External-Core files for the
necessary libraries.


\subsection{How to fix it}

% TODO: Should i link to the bugs ???

GHC includes a library, it should be doable to use this library to get
GHCs own internal Core representation when compiling a file. Using this 
representation, it should be easy to create a JSCore-like format to use.

However, to do this, the step performing this must be a linked into the
actual GHC binary, as it is not possible to compile the Base package without
actually compiling GHC. This is also due to a bug in GHC.













\section{Implementation}

Writing interpreters in RPython is efficient.... Most of the time was spent on
trying to figure out how to deal with the issues of interpreting Core, and the
primitives.

What has been the key choices ??? How did these choices we made work out ???

\section{Benchmarks}

Can we do any kind of benchmarking ??? If not, how far along of some 
benchmarking are we ???

\section{Future work}

\begin{itemize}

\item Drop the use of External-Core. Use the GHC API to compile Haskell programs
into JSCore (or something similar). The difficult part will be how to compile
multiple Haskell source files. And figuring out how to get information from the
current buildsystems into our program. This information includes:

\begin{itemize}

\item Language extensions
\item Dependencies
\item Packages
\item And any other information necessary to build the program.

\end{itemize}

\end{itemize}


