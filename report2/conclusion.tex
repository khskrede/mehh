
\chapter{Conclusion and Future Work}
\label{chap:conc}


\section{Serializing and deserializing}

The current situation regarding the serialization of Haskell programs into 
the JSCore format have several problems. It is dependent on a buggy part of GHC, 
and on a poorly maintained package (extcore). The result of these bugs is that
GHC exits with a panic-error when compiling some Haskell modules. And this in
turn, means that we have been unable to create JSCore for the GHC boot libraries.

Currently, the libraries necessary to run some simple Haskell programs have been
implemented at a high level in Python. This implementation is not "correctly"
implemented with regard to the Haskell language, but it is sufficient in order
to test some simple programs.

Some alternative methods have been investigated as solutions for this problem,
including the use of the Cabal (Haskell package system) API in collaboration
with the GHC API in order to create the JSCore files. However, Cabal interface
with GHC through command line arguments. 
It was also attempted to create the necessary functionality using just the GHC
API, however this also turned out to be problematic. Though it now seems like
this is the best way to move forward. By using the main module as the base for
the serializer, it should be possible to interface with the build-system
exactly like GHC does. This would mean that it would be possible to write a
fairly simple Haskell function to dump the intermediate format used by GHC
to JSCore, and since this program would function exactly like GHC, anything 
would be possible to compile using it.

The deserialization should not change much, as the JSCore intermediate format
would not have to change very much. If anything, the JSCore format can be
simplified, and made to match better against Core and System $F_C$ than
External-Core does. It is however, necessary to improve the serialization
functionality before the deserialization can be improved much as the programs
that can be serialized is of little complexity, and therefore does not test
very much.


\section{Benchmarking and testing}

Some simple benchmarking and testing was done. The benchmarking was done by
running the naive fibonacci program with $n=40$, the results can be seen in
table \ref{tab:benchmarks}.
It is clear that the interpreter must be optimized 
further if it is to compete with GHC. A significant increase in execution 
time with the JIT as opposed to without the JIT was observed. In addition,
for this benchmark, the interpreter with JIT was approximately $3.3$ times faster than
$runhaskell$ (an interpreter that comes with GHC).

\begin{table}[H]

\centering
\begin{tabular}{l|l}
\hline
\hline
Compilation System & Time \\
\hline
GHC               & 0m 11.296s  \\
runhaskell        & 4m 23.803s \\ 
PyHaskell no JIT   & 12m 57.254s \\
PyHaskell JIT      & 1m 20.638s \\
\hline
\end{tabular}

\caption{Timing results for running the naive fibonacci implementation with n=40. Results
are from the "user" output of the "time" linux command.}
\label{tab:benchmarks}


\end{table}

The testing performed has been described in chapter \ref{chap:impl}. The results of the 
testing is that the current implementation is sufficient for simple programs taking 
advantage of various Haskell constructs. It is also clear that this is not sufficient
to run any more complicated programs, but it serves well for the future development of
the system. Eventually, the interpreter should run the GHC benchmarking suite (NoFib) and 
the GHC testsuit.

\section{Concluding remarks}

%NoFib GHC benchmark

The goals of this project was to investigate whether Haskell could benefit from JIT 
compilation. Unfortunately, this question remains unanswered at this stage, as the
approach taken to test the hypothesis has not been successfully completed. However,
based on the results from this partially implemented system, its continued
development may result in a fast Haskell compilation system, and may eventually prove
the hypothesis true.


