
\section{Conclusion and Future Work}
\label{chap:conc}


\subsection{Serializing and Deserializing}

The current situation regarding the serialization of Haskell programs into 
the JSCore format have several problems. It is dependent on a buggy part of GHC, 
and on a poorly maintained package (extcore). The result of these bugs is that
GHC exits with a panic-error when compiling some Haskell modules. And this in
turn, means that we have been unable to create JSCore for the GHC boot libraries.

Currently, the libraries necessary to run some simple Haskell programs have been
implemented at a high level in Python. This implementation is not "correctly"
implemented with regard to the Haskell language, but it is sufficient in order
to test some simple programs.

Some alternative methods have been investigated as solutions for this problem,
including the use of the Cabal (Haskell package system) API in collaboration
with the GHC API in order to create the JSCore files. However, Cabal interface
with GHC through command line arguments. 
It was also attempted to create the necessary functionality using just the GHC
API, however this also turned out to be problematic. Though it now seems like
this is the best way to move forward. By using the main module as the base for
the serializer, it should be possible to interface with the build-system
exactly like GHC does. This would mean that it would be possible to write a
fairly simple Haskell function to dump the intermediate format used by GHC
to JSCore, and since this program would function exactly like GHC, anything 
would be possible to compile using it.

The deserialization should not change much, as the JSCore intermediate format
would not have to change very much. If anything, the JSCore format can be
simplified, and made to match better against Core and System $F_C$ than
External-Core does. It is however, necessary to improve the serialization
functionality before the deserialization can be improved much as the programs
that can be serialized is of little complexity, and therefore does not test
very much.




\begin{comment}

\section{Primitives and Libraries}

\subsection{The initial plan}

GHC uses a module called GHC.Prim, located in the ghc-prim package. This
module is generated automatically from a file called "primops.txt.pp", this file
contains information about the machine representations of the various types, as
well as the operations that can be performed on them.

Initially, it was assumed that it would be trivial to translate the Haskell
libraries used by GHC into External-Core using GHC. This way, it would only 
be necessary to implement the primitive types and functions.

The External-Core functionality of GHC has bitrotted, and because of this, it can't be
used to create External-Core files for all the GHC libraries. This is a GHC bug. 
Although it produces correct
External-Core for some Haskell code, it does not for all. Since many crucial library files
can not be created External-Core for, we can not continue to use this approach.

\subsubsection*{Our approach}

Currently, GHC is used to parse, typecheck, desugar and generate the 
External-Core representation of our program. By implementing the
primitive types and library functionality in Python, we are able to
get some simple programs running.


\subsubsection*{Why it does not work}

% TODO: Libraries use Haskell code not supported by the External-Core libraries.

The initial reasoning for using External-Core was as follows;
it has a clearly defined syntax that is easy to work with, and it was 
assumed that it was decently supported. Unfortunately, there are bugs in
the parts of GHC responsible for generating External-Core, this in turn
results in the fact that we are unable to create External-Core files for the
necessary libraries.


\subsubsection*{How to fix it}

% TODO: Should i link to the bugs ???

GHC includes a library, it should be doable to use this library to get
GHCs own internal Core representation when compiling a file. Using this 
representation, it should be easy to create a JSCore-like format to use.

However, to do this, the step performing this must be a linked into the
actual GHC binary, as it is not possible to compile the Base package without
actually compiling GHC. This is also due to a bug in GHC.













\subsection{Implementation}

Writing interpreters in RPython is efficient.... Most of the time was spent on
trying to figure out how to deal with the issues of interpreting Core, and the
primitives.

What has been the key choices ??? How did these choices we made work out ???

\subsection{Benchmarks}

Can we do any kind of benchmarking ??? If not, how far along of some 
benchmarking are we ???

\subsection{Future work}

\begin{itemize}

\item Drop the use of External-Core. Use the GHC API to compile Haskell programs
into JSCore (or something similar). The difficult part will be how to compile
multiple Haskell source files. And figuring out how to get information from the
current buildsystems into our program. This information includes:

\begin{itemize}

\item Language extensions
\item Dependencies
\item Packages
\item And any other information necessary to build the program.

\end{itemize}

\end{itemize}

\end{comment}
